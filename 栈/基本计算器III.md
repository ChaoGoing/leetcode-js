# 思路：
## 1.维护nums 和 ops 两个栈,
num：存放所有的数字
ops：存放数字之外的操作

## 2.遍历过程
- 空格: 跳过
- (: 加入ops中，等待与之匹配的)
- ): 使用现有的nums和ops进行计算，直到遇到左边最近的一个左括号为止， 计算结果放到nums中
- 数字：从当前位置开始往后取，截取连续的一个数字并存大奥nums中
- +-*/%:将操作放入ops栈中,放入前把栈内可以算的都进行计算并重新压入栈（只有满足栈的运算符优先级大于当前运算符优先级/同等才可以计算）

## 细节：
1.node中 s.replace 不会修改原来的字符串
2.只有在截取数字时才需要手动i++
3.为防止 () 内出现的首个字符为运算符，将所有的空格去掉，并将 (- 替换为 (0-，(+ 替换为 (0+（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）
4.由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 nums 添加一个 0
